<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TV Grid — Remote Navigation Example</title>
  <style>
    :root{
      --gap: 24px;
      --item-w: 280px; /* tile width */
      --item-h: 160px; /* tile height */
    }

    html,body{height:100%;margin:0;background:#07080b;color:#fff;font-family:system-ui,Arial,Helvetica,sans-serif}
    .app{
      box-sizing:border-box;
      padding:40px;
      height:100%;
      display:flex;
      flex-direction:column;
      gap:20px;
    }

    header{font-size:20px;opacity:0.9}

    /* Grid container */
    .grid-wrap{
      flex:1; /* fill space */
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      padding-bottom:30px;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--item-w), 1fr));
      gap:var(--gap);
      align-content:start;
      justify-content:start; /* keeps left alignment */
    }

    .tile{
      width:var(--item-w);
      height:var(--item-h);
      background:linear-gradient(180deg,#111418 0%, #1b1f26 100%);
      border-radius:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      outline:none; /* we handle focus style */
      user-select:none;
    }

    /* Focus style that's TV-friendly */
    .tile:focus{
      transform:translateY(-6px) scale(1.03);
      box-shadow:0 18px 40px rgba(0,0,0,0.7), 0 0 0 6px rgba(255,255,255,0.06) inset;
      border:3px solid rgba(255,255,255,0.06);
      transition:transform 120ms ease, box-shadow 120ms ease;
      z-index:2;
    }

    .meta{font-size:12px;opacity:0.7;margin-top:6px}

    /* small helper HUD */
    .hud{position:fixed;right:20px;bottom:20px;background:rgba(0,0,0,0.45);padding:10px 14px;border-radius:8px;font-size:12px}

    @media (max-width:900px){
      :root{--item-w:220px;--item-h:140px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>TV Grid — use remote arrow keys (←↑→↓), Enter to select, Back/Escape to go back</header>

    <div class="grid-wrap" id="gridWrap" tabindex="0">
      <div class="grid" id="grid"></div>
    </div>

    <div class="hud" id="hud">Focused: <span id="hudIndex">—</span></div>
  </div>

  <script>
    // TV Grid example with remote-friendly D-pad navigation.
    // Features:
    // - Arrow key navigation (Left/Right/Up/Down)
    // - Enter to 'activate'
    // - Back/Escape to simulate back
    // - Smooth scrolling and visible focus
    // - Responsive column calculation

    const grid = document.getElementById('grid');
    const gridWrap = document.getElementById('gridWrap');
    const hudIndex = document.getElementById('hudIndex');

    const TOTAL = 60; // change to create more/less tiles

    // Create tiles
    for (let i=0;i<TOTAL;i++){
      const t = document.createElement('button');
      t.className = 'tile';
      t.type = 'button';
      t.dataset.index = i;
      t.setAttribute('tabindex','-1'); // we'll manage focus programmatically
      t.innerHTML = `<div>Item ${i+1}</div>`;
      t.addEventListener('click', ()=> alert('Activated item '+(i+1)));
      grid.appendChild(t);
    }

    let tiles = Array.from(grid.children);
    let focusedIndex = 0;

    // compute columns based on layout and item size
    function computeColumns(){
      if (!tiles.length) return 1;
      // find the first tile width + gap
      const wrapWidth = grid.clientWidth;
      const tileWidth = tiles[0].offsetWidth || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--item-w'));
      const gap = parseInt(getComputedStyle(grid).gap) || parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
      const columns = Math.max(1, Math.floor((wrapWidth + gap) / (tileWidth + gap)));
      return columns;
    }

    let columns = computeColumns();

    // Set initial focus
    function focusIndex(idx){
      if (idx < 0) idx = 0;
      if (idx >= tiles.length) idx = tiles.length - 1;
      focusedIndex = idx;
      const el = tiles[focusedIndex];
      // ensure only focused tile is tabbable
      tiles.forEach((t,i)=> t.setAttribute('tabindex', i===focusedIndex ? '0' : '-1'));
      el.focus({preventScroll:true});
      // ensure visible
      el.scrollIntoView({block:'nearest', inline:'nearest', behavior:'smooth'});
      hudIndex.textContent = (focusedIndex+1) + ' / ' + tiles.length;
    }

    // Basic navigation
    function move(delta){
      columns = computeColumns();
      let next = focusedIndex + delta;
      if (delta === -1 || delta === 1){
        // left/right: clamp within row
        const rowStart = Math.floor(focusedIndex / columns) * columns;
        const rowEnd = Math.min(rowStart + columns - 1, tiles.length - 1);
        if (next < rowStart) next = rowStart; // prevent wrapping to prev row
        if (next > rowEnd) next = rowEnd;
      } else {
        // up/down: clamp to bounds
        if (next < 0) next = 0;
        if (next >= tiles.length) next = tiles.length - 1;
      }
      focusIndex(next);
    }

    // handle keydown from remote
    function onKey(e){
      // some remotes send different codes; normalize
      const k = e.key;
      const KEY = k.toLowerCase();

      if (KEY === 'arrowleft'){
        e.preventDefault(); move(-1);
      } else if (KEY === 'arrowright'){
        e.preventDefault(); move(1);
      } else if (KEY === 'arrowup'){
        e.preventDefault(); move(-columns);
      } else if (KEY === 'arrowdown'){
        e.preventDefault(); move(columns);
      } else if (KEY === 'enter' || KEY === 'ok'){
        e.preventDefault(); tiles[focusedIndex].click();
      } else if (KEY === 'escape' || KEY === 'back'){
        e.preventDefault(); console.log('Back requested');
        // implement your back logic here
      }
    }

    // Listen at document so that focus is not required on the gridWrap
    document.addEventListener('keydown', onKey);

    // Recompute columns on resize and when styles change
    let resizeTimer;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{
        columns = computeColumns();
      },80);
    });

    // When focus changes by other means (mouse), update index
    grid.addEventListener('focusin', (e)=>{
      const idx = tiles.indexOf(e.target);
      if (idx >= 0) { focusedIndex = idx; hudIndex.textContent = (focusedIndex+1)+' / '+tiles.length }
    });

    // initial focus after a short delay so layout is stable
    setTimeout(()=> focusIndex(0), 50);

    // Optional: support number keys to jump
    document.addEventListener('keypress', (e)=>{
      if (e.key >= '1' && e.key <= '9'){
        const num = parseInt(e.key,10);
        const target = Math.min(num-1, tiles.length-1);
        focusIndex(target);
      }
    });

    // Expose for debugging
    window.tvGrid = { focusIndex, tiles };
  </script>
</body>
</html>
